{"pages":[{"title":"Career","text":"CareerStatistics (2018-12-27 ~ 2019-05-28)사용기술 : SPA, Vue.js, webpack, javascript, Git티켓링크 구단별 판매 데이터 분석 사이트 개발- vue-cli를 사용하여 frontend 프로젝트 셋팅- Vue.js를 사용하여 UI 개발- tui-chart 라이브러리를 사용하여 데이터 시각화 KIOSK (2018-06-11 ~ 2018-08-10)사용기술 : SPA, Vue.js, webpack, javascript, Git티켓링크 현장 발권 시스템 Front 개발- Vue.js를 사용하여 UI 개발- 티켓 출력에 필요한 라이브러리 이전 모바일 보고서 (2018-02-13 ~ 2018-04-04)사용기술 : Springboot, JAVA, AngularJS, jQuery, javascript, mybatis, mysql, Git티켓링크 구단별 판매 현황 및 통계 데이터 시각화- springboot으로 프로젝트 셋팅- backend 개발- frontend 개발- 모바일 웹 티켓링크 사이트 운영 및 추가개발 (2017-12-11 ~ 진행중)사용기술 : Springboot, JAVA, AngularJS, Vue.js, jQuery, javascript, mybatis, mysql, Git티켓링크 admin / front(b2c) 개발 및 운영- MPA로 Vue.js를 이용하여 Front 개발- AngularJS를 이용하여 Front 유지보수 SK플래닛 Big Data Discovery (2016-03-02 ~ 2017-08-04)사용기술 : Springboot, JAVA, JPA, JSP, jQuery, AngularJS(1.x), HalBrowser, Git메타트론 ( 빅데이터 분석 솔루션 )- AngularJS를 이용하여 Front 개발- eChart.js 라이브러리를 사용하여 데이터 시각화 한국언론진흥재단 대외서비스 구축 (2015-01-29 ~ 2016-02-12)사용기술 : JAVA, JEUS, trustForm, javascript, jQuery, MyBatis, svn한국언론진흥재단 admin 개발- 언론인 금고 ( 대출신청, 상환내역 조회 )- 임대 대관 ( 대관 예약 및 일정 조회 ) 삼성닷컴 NextGen 안정화 지원 (2014-10-01 ~ 2015-01-14)사용기술 : JAVA, Spring framework, JSP, javascript, jQuery, iBatis, svn삼성닷컴 운영 및 안정화 지원 삼성닷컴 NextGen B2C Support (2014-08-01 ~ 2014-09-30)사용기술 : JAVA, Spring framework, JSP, javascript, jQuery, iBatis, svn삼성닷컴 Support 페이지 및 만족도 조사 페이지 개발 삼성물산 상사 컴플라이언스 포탈 (2014-05-08 ~ 2014-07-31)사용기술 : JAVA, Spring framework, JSP, javascript, jQuery, MyBatis, svn삼성물산 사내 사이트 개발- DB설계 ( ORACLE )- 삼성물산 포탈 내 설문 등록 및 조회, 참여, 분석 페이지 개발 삼성닷컴 NextGen 구축 PILOT (2013-10-14 ~ 2014-04-17)사용기술 : JAVA, Spring framework, JSP, javascript, jQuery, iBatis, svn삼성닷컴 B2C 개발- 상품 목록 카테고리 및 필터링 조회- AS-IS API 이전","link":"/about/index.html"}],"posts":[{"title":"20201024","text":"블로그를 만들어 보았습니다. 허허…","link":"/2020/10/24/20201024/"},{"title":"Throttle과 Debounce","text":"두 가지 방법 모두 성능상의 이유로 이벤트를 제어(제한)하는 방법이벤트 핸들러가 많은 연산 (예: 무거운 계산, DOM 조작 등)을 수행할할 때, 이벤트가 과도한 횟수로 발생하는 것에 대한 제약을 걸어 제어 Throttle마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출하지 않도록 하는 것일정한 주기마다 이벤트가 발생하도록 하는 것Throttle의 설정시간으로 1ms를 주게되면 이벤트는 1ms동안 최대 한번만 실행normal : event1, event2, event3, event4 ...throttle : event1(1ms)event2(1ms)event3 ... throttle example : // 5초마다 비디오 목록을 조회...initVideo: _.throttle(async function initVideo() { try { const videos = await api.getVideos(); ... } catch (e) { console.error(e); }}, 5000)... Debounce연이어 호출되는 함수들 중 처음 혹은 마지막으로 호출된 함수만 실행하도록 하는 것순차적으로 호출되는 동일한 이벤트를 하나로 그룹화Debounce의 설정시간으로 5ms를 주게되면 5ms동안 이벤트가 호출되지 않아야 마지막 호출 실행normal : event1, event2, event3, event4 ... (전부실행)debounce : event1, event2, event3 (5ms) ... (event3만 실행) debounce example : utils.js;let timer = null;export const debounce = (time, value, search) =&gt; { // time만큼 이벤트가 발생하지 않아야 api 호출 if (timer) { clearTimeout(timer); } timer = setTimeout(() =&gt; { search(value); timer = null; }, time);}; search.jsimport { debounce } from './utils.js'...this.$input.addEventListener('keyup', (e) =&gt; { debounce(500, e.target.value, search);});... Throttle과 Debounce의 차이점가장 큰 차이점은 throttle은 설정한 시간마다 정기적인 실행을 보장하는 것debounce의 경우 아무리 많은 이벤트가 발생한다 하여도 특정 시간동안 이벤트가 발생하지 않았을 때 한번 이벤트를 발생시키는 기법 Ref.쓰로틀링과 디바운싱디바운스(Debounce)와 스로틀(Throttle) 그리고 차이점","link":"/2020/10/25/Throttle%EA%B3%BC-Debounce/"},{"title":"간단한 스크립트 풀이1","text":"Q. 스크립트 실행 시 예상되는 결과는 ? var data1 = &quot;FOO&quot;;function outer() { console.log(data1); var data1 = &quot;BAR&quot;; var data2 = &quot;VAR&quot;; console.log(data2); function inner() { console.log(this.data1); console.log(this.data2); } inner(); return inner;}var obj = { data1: &quot;BAZ&quot;, data2: &quot;TAZ&quot;,};var func = outer();func.call(obj); A. undefined (1)VAR (2)FOO (3)undefined (4)BAZ (5)TAZ (6) 풀이 (1) outer 함수 실행 시, 호이스팅으로 인해 data1 변수에 대해 할당된 undefined 가 출력 function outer() { var data1, data2; console.log(data1); var data1 = &quot;BAR&quot;; var data2 = &quot;VAR&quot;; console.log(data2);} (2) data2에 할당된 VAR가 출력 (3)(4) innner 실행 시 this는 window이기 때문에 window.data1은 undefined, window.data2는 첫 줄에 선언된 FOO가 출력 (5)(6) call로 호출하며 obj를 인자로 전달하였으므로 this는 obj이기 때문에 각 변수값 출력","link":"/2020/10/26/%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%92%80%EC%9D%B41/"},{"title":"prototype","text":"자바스크립트는 JAVA, C++과는 다른 프로토타입 기반의 객체 지향 프로그래밍을 지원한다.객체 리터럴이나 생성자 함수로 객체를 생성하고, 이렇게 생성된 객체의 부모 객체가 바로 프로토타입객체다.상속 개념과 마찬가지로 자식 객체는 부모 객체가 가진 프로퍼티나 메소드에 접근, 사용이 가능하다. 볼때마다 헷갈리는 두 가지 프로토타입 함수 객체의 prototype 프로퍼티 객체의 숨은 프로퍼티인 __proto__ 자바스크립트의 모든 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가르키는 프로토타입 객체를 자신의 부모 객체로 설정하는 __proto__로 연결한다. function Person(name) { this.name = name;}const foo = new person(&quot;foo&quot;); Person() 생성자 함수의 prototype 프로퍼티와 foo 객체의 __proto__ 가 같은 프로토타입 객체를 바라보고 있다.프로토타입 객체의 constructor가 Person() 생성자 함수를 가르키고 있다. 객체의 프로토타입 체이닝특정 객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티나 메소드가 없다면 __proto__ 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 차례대로 검색한다. 이것을 가능케 하는 것이 바로 프로토타입 체이닝이다. Object.prototype프로토타입 체이닝의 종점자바스크립트 모든 객체의 조상 역할을 하는 객체로서, 자바스크립트 모든 객체가 호출할 수 있는 toString(), hasOwnProperty() 등과 같은 표준 메서드를 제공한다. 기본 데이터 타입 확장네이티브 프로토타입 객체(String.prototype, Object.prototype…)에 사용자가 직접 정의한 메서드를 추가할 수 있다. String.prototype.testMethod = function () { console.log(&quot;This is the String.prototype.testMethod()&quot;);}; 프로토타입도 자바스크립트 객체다함수가 생성될 때, 자신의 prototype 프로퍼티에 연결되는 프로토타입 객체는 디폴트로 constructor 프로퍼티만을 가진 객체다.당연히 프로토타입 객체 역시 자바스크립트 객체이므로 일반 객체러럼 동적으로 프로퍼티를 추가/삭제 하는것이 가능하다.이렇게 변경된 프로퍼티는 실시간으로 프로토타입 체이닝에 반영된다. function Person(name) { this.name = name;}const foo = new Person(&quot;foo&quot;);Person.prototype.sayHello = function () { console.log(&quot;Hello&quot;);};foo.sayHello(); // hello 프로토타입 메서드와 this프로토타입 객체도 객체이므로 프로퍼티로 메서드를 가질 수 있으며 해당 메서드 안에서 this는 this 바인딩 규칙에 따라 해당 메서드를 호출한 객체에 바인딩 된다. 디폴트 프로토타입은 다른 객체로 변경이 가능하다디폴트 프로토타입 객체는 함수가 생성될 때 같이 생성되며, 함수의 prototype 프로퍼티에 연결된다.이 디폴트 프로토타입 객체를 다른 객체로 변경하는 것이 가능하다.여기서 주의할 점은, 생성자 함수의 프로토타입 객체가 변경되면 변경된 시점 이후에 생성된 객체들은 변경된 프로토타입 객체로 __proto__링크를 연결한다.변경되기 이전에 생성된 객체들은 기존 프로토타입 객체로 __proto__링크를 유지한다. function Person(name) { this.name = name;}console.log(Person.prototype.constructor); // Person(name)const foo = new Person('foo');console.log(foo.country); // undefinedPerson.prototype = { country: 'korea';}console.log(Person.prototype.constructor); // Object()const bar = new Person('bar');console.log(foo.country); // undefinedconsole.log(bar.country); // koreaconsole.log(foo.constructor); // Person(name) &lt;-- foo에 constructor가 없으므로 프로토타입 체이닝 발생!console.log(bar.constructor); // Object() &lt;-- bar에 constructor가 없으므로 프로토타입 체이닝 발생!","link":"/2020/10/29/prototype/"},{"title":"객체와 함수 그리고 this","text":"자바스크립트의 거의 모든 것은 객체이다. 객체 생성 기본 Object() 객체 생성자 함수 const foo = new Object();foo.name = &quot;foo&quot;;foo.age = 30;foo.gender = &quot;male&quot;;console.log(typeof foo); // objectconsole.log(foo); // { name: 'foo', age: 30, gender: 'male'} 객체 리터럴 const foo = { name: &quot;foo&quot;, age: 30, gender: &quot;male&quot;,};console.log(typeof foo); // objectconsole.log(foo); // { name: 'foo', age: 30, gender: 'male'} 생성자 함수 생성자 함수는 말 그대로 자바스크립트의 객체를 생성하는 역할을 한다. 기존 함수에 new 연산자를 붙여서 호출하면 함수는 생성자 함수로 동작한다. const Person = function (name) { // 함수코드 실행 전 (1) this.name = name; // 함수 리턴 ()};const foo = new Person(&quot;foo&quot;);console.log(foo.name); // foo Person() 함수가 생성자로 호출되면, 함수 코드가 실행되기 전 빈 객체가 생성된다.빈 객체에 name이라는 프로퍼티를 동적으로 생성하여 객체를 리턴한다. 생성자 함수가 동작하는 방식 빈 객체 생성 및 this 바인딩 생성자 함수 코드가 실행되기 전 빈 객체가 생성된다. 바로 이 객체가 생성자 함수가 새로 생성하는 객체이며, 이 객체는 this로 바인딩 된다. 따라서 이후 생성자 함수의 코드 내부에서 사용되는 this는 이 빈 객체를 가르킨다. 하지만, 여기서 생성된 객체는 엄밀히 말하면 빈 객체는 아니다. 자바스크립트의 모든 객체는 자신의 부모인 프로토타입 객체와 연결되어 있으며, 이를 통해 부모의 객체의 프로퍼티나 메서드를 마치 자신의 것처럼 사용할 수 있기 때문이다. 이렇게 생성자 함수가 생성한 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가르키는 객체를 자신의 프로토타입 객체로 설정한다. this를 통한 프로퍼티 생성 생성된 객체 리턴 리턴문이 없을 경우this로 바인딩된 새로 생성한 객체가 리턴(생성자 함수가 아닌 일반 함수를 호출할 때 리턴값이 명시되어 있지 않으면 undefined가 리턴된다) 다른 객체를 리턴하는 경우생성자 함수를 호출 했다고 하더라도 this가 아닌 해당 객체로 리턴된다.생성자 함수의 리턴 값으로 넘긴 값이 객체가 아닌 불린, 문자열, 숫자인 경우는 이러한 리턴값을 무시하고 this로 바인딩 된 객체가 리턴된다. 함수 생성자바스크립트에서는 함수를 생성하는 방법이 3가지가 있다.각각의 방식에 따라 함수 동작이 미묘하게 달라진다. 함수 리터럴함수 리터럴 방식으로 정의되는 함수는 함수명이 생략 가능하다. 함수명이 없는 함수를 익명함수라 한다. &lt;-&gt; 기명함수 function add(x, y) { return x + y;} 함수 선언문 선언문 방식으로 정의된 함수는 반드시 함수명이 정의되어 있어야 한다. function add(x, y) { return x + y;} 함수 표현식 함수 리터럴로 하나의 함수를 만들고, 여기서 생생된 함수를 변수에 할당하여 함수를 생성한다. 자바스크립트에서는 함수도 하나의 값처럼 취급되기 때문에 함수도 변수에 할당하는 것이 가능하다. const add = function (x, y) { return x + y;};const plus = add;console.log(add(3, 4)); // 7console.log(plus(4, 6)); // 11// add와 plus 함수 변수는 두 개의 인자를 더하는 동일한 익명 함수를 참조한다 Function() 생성자 함수 자바스크립트의 함수도 Function()이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있다. 함수 선언문, 함수 표현식 모두 함수 리터럴 방식으로 함수를 생성하지만, 결국 내부적으로 Function() 생성자 함수로 함수가 생성된다고 볼 수 있다. new Function(arg1, arg2, ... , functionBody) const add = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x + y&quot;); 함수 생성 방식에 따라 달라지는 함수 호이스팅add(2, 3); // 5// 함수 선언문으로 정의function add(x, y) { return x + y;}add(3, 4); // 7 함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작 add(2, 3); // uncaught type errorconst add = function (x, y) { return x + y;};add(3, 4); // 7 함수 표현식 형태로 정의되어 있는 함수는 함수 변수는 생성되나 초기화가 되지 않아 호출이 불가 자바스크립트에서는 함수도 객체다함수의 기본 기능인 코드 실행뿐만 아니라, 함수 자체도 일반 객체처럼 프로퍼티들을 가질 수 있다.함수를 생성할 때 함수 코드는 함수 객체의 [[Code]] 내부 프로퍼티에 자동으로 저장된다. 자바스크립트에서는 함수도 값으로 취급된다함수도 일반 객체처럼 취급될 수 있다. 리터럴에 의해 생성변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능 (객체의 프로퍼티가 함수이면 메서드라고 부른다)함수의 인자로 전달 가능함수의 리턴값으로 리턴 가능동적으로 프로퍼티 생성 및 할당 가능 이와 같은 특징이 있으므로 자바스크립트에서 함수를 일급객체라고 부른다. 함수의 프로퍼티 name : 함수의 이름, 익명함수의 경우 빈 문자열caller : 자신을 호출한 함수arguments : 함수를 호출할 때 전달된 인자값 (유사 배열 형태)length : 함수 호출 시 전달받은 인자의 개수___proto__ : 밑에 따로 설명.. 함수 객체의 부모 역할을 하는 프로포타입 객체는 Function.prototype이며 이를 함수 객체라 한다. Function.prototype 객체가 가지는 프로퍼티constructortoString()apply()call()bind() Function.prototype 객체의 프로토타입 객체는 Object.prototype이다. prototype프로퍼티와 __proto__모든 객체는 자신의 부모를 가르키는 __proto__(프로토타입 객체)를 가진다.모든 함수는 객체로서 prototype 프로퍼티를 가지고있다.두 프로퍼티 모두 프로토타입 객체를 가르킨다는 점에서는 공통점이 있지만, 관점의 차이가 있다.모든 객체는 내부 프로퍼티인 __proto__는 객체 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가르키는 반면,함수 객체가 가지는 prototype 프로퍼티는 이 함수가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 객체를 가르킨다. 자바스크립트의 모든 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체를 자신의 부모 객체인 __proto__로 연결한다. arguments 객체자바스크립트에서는 함수를 호출할 때 함수 형식에 맞춰 인자를 넘기지 않더라도 에러가 발생하지 않는다.정의된 함수의 인자보다 적게 함수를 호출 했을 경우, 넘겨지지 않은 인자에는 undefined가 할당된다.반대로 정의된 인자 개수보다 많게 함수를 호출했을 경우는 초과된 인수는 무시된다.자바스크립트의 이러한 특성 때문에 함수 코드를 작성할 때, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있다.이를 가능케 하는 게 바로 argunmets 객체이다.함수를 호출할 때 넘긴 인자들을 유사 배열 형태로 arguments 객체에 저장되어 전달된다. arguments 객체의 구성호출 시 넘겨진 인자 : 배열형태로 전달length 프로퍼티 : 호출할 떄 넘긴 인자의 개수를 의미callee 프로퍼티 : 현재 실행 중인 함수의 참조값 arguments는 객체이지 배열이 아니다. 함수 호출 방식에 따라 달라지는 this 객체의 메서드를 호출할 때 해당 메서드를 호출한 객체로 바인딩 const myObject = { name: &quot;foo&quot;, sayName: function () { console.log(this.name); },};const otherObject = { name: &quot;bar&quot;,};otherObject.sayName = myObject.sayName;console.log(myObject.sayName()); // fooconsole.log(otherObject.sayName()); // bar// this는 자신을 호출한 객체에 바인딩 함수를 호출할 때 함수를 호출하면 해당 함수 내부 코드에서 사용되는 this는 젼역 객체에 바인딩 브라우저 환경에서 자바스크립트를 실행하는 경우, 젼역 객체는 window 객체Node.js와 같은 런타임 환경에서 전역 객체는 global 객체 함수 안의 내부 함수를 호출했을 경우에도 그대로 적용되므로, 내부 함수에서 this를 사용할 때 주의 생성자 함수를 호출 했을 때 생성자 함수 코드가 실행되기 전 빈 객체가 생성되며, 이 객체가 this로 바인딩","link":"/2020/11/01/%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%95%A8%EC%88%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-this/"},{"title":"실행 컨텍스트와 스코프 체인","text":"실행컨텍스트실행 가능한 코드를 형상화하고 구분하는 추상적인 개념 콜스택함수 호출 정보가 차곡차곡 쌓이는 스택을 의미한다.실행 컨텍스트는 콜 스택에 들어가는 실행 정보 하나와 비슷하다. 실행 가능한 자바스크립트 코드 블록이 실행되는 환경여기서 말하는 코드 블록이란 대부분의 경우 함수가 된다.이 코드 블록 안에는 변수 및 객체, 실행 가능한 코드가 코드가 들어있다. 실행 컨텍스트가 형성되는 경우 전역코드 eval() 함수로 실행되는 코드 함수 안의 코드를 실행할 경우 현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면, 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 이동한다. 실행 컨텍스트 생성 과정function excute(param1, param2) { var a = 1, b = 2; function func() { return a + b; } return param1 + param2 + func();}excute(3, 4); 자바스크립트에서 함수를 실행하여 실행 컨텍스트가 생성되면 자바스크립트 엔진은 다음과 같은 일을 정해진 순서대로 실행한다. 활성 객체 생성 (변수객체)실행 컨텍스트가 생성되면 자바스크립트 엔진은 해당 컨텍스트에서 실행에 필요한 여러가지 정보를 담을 객체를 생성하는데 이를 활성 객체라고 한다. arguments 객체 생성활성 객체는 arguments 프로퍼티로 arguments 객체를 참조한다. 스코프 정보 생성현재 컨텍스트의 유효 범위를 나타내는 스코프 정보를 생성한다. 이 스코프 정보는 현재 실행 중인 실행 컨텍스트 안에서 연결 리스트와 유사한 형식으로 만들어 진다. 이 리스트로 현재 컨텍스트의 변수 뿐만 아니라, 상위 실행 컨텍스트의 변수에도 접근이 가능하다. 이 리스트를 스코프 체인이라고 하며 [[scope]]프로퍼티로 참조된다. 변수 생성현재 실행 컨텍스트 내부에서 사용되는 지역 변수의 생성이 이루어진다. 여기서 주의 할 점은 이 과정에서는 변수나 내부 함수를 단지 메모리에 생성하고, 초기화는 각 변수나 함수에 해당하는 표현식이 실행되기 전까지는 이루어지지 않는다는 점이다. this 바인딩 코드 실행하나의 실행 컨텍스트가 생성되고, 변수 객체가 만들어진 후에 코드에 있는 여러가지 표현식 실행이 이루어진다. 전역 실행 컨텍스트전역 실행 컨텍스트는 arguments 객체가 없으며, 전역 객체 하나만을 포함하는 스코프 체인이 있다.전역 실행 컨텍스트의 변수 객체가 곧 전역 객체이다. 스코프 체인유효 범위를 나타내는 스코프가 [[scope]]프로퍼티로 각 함수 객체 내에서 연결 리스트 형식으로 관리되며 이를 스코프 체인이라고 한다.스코프 체인은 각 실행 컨텍스트의 활성 객체(변수 객체)가 구성 요소인 리스트와 같다.한 함수가 실행되면 새로운 실행 컨텍스트가 만들어 지는데, 이 새로운 컨텍스트는 자신이 사용할 스코프 체인을 다음과 같은 방법으로 만든다. 현재 실행되는 함수 객체의 [[scope]] 프로퍼티를 복사하고, 새롭게 생성된 변수 객체를 해당 체인의 제일 앞에 추가한다.스코프 체인 = 현재 실행 컨텍스트의 변수 객체 + 상위 컨텍스트의 스코프 체인 var value = &quot;value1&quot;;function printFunc() { var value = &quot;value2&quot;; function printValue() { return value; } console.log(printValue());}printFunc(); var value = &quot;value1&quot;;function printValue() { return value;}function printFunc(func) { var value2 = &quot;value2&quot;; console.log(func());}printFunc(printValue()); 각 함수 객체가 처음 생성될 당시 실행 컨텍스트가 무엇인지 생각해야 한다.","link":"/2020/11/01/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8/"}],"tags":[{"name":"throttle","slug":"throttle","link":"/tags/throttle/"},{"name":"debounce","slug":"debounce","link":"/tags/debounce/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"hoisting","slug":"hoisting","link":"/tags/hoisting/"},{"name":"prototype","slug":"prototype","link":"/tags/prototype/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"excution context","slug":"excution-context","link":"/tags/excution-context/"},{"name":"activation object","slug":"activation-object","link":"/tags/activation-object/"},{"name":"scope chain","slug":"scope-chain","link":"/tags/scope-chain/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"}]}